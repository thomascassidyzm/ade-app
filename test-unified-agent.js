// Test Unified Agent - Tests the new ADE unified infrastructure
const WebSocket = require('ws');
const axios = require('axios');

class TestUnifiedAgent {
  constructor(agentId, serverUrl = 'http://localhost:3000') {
    this.agentId = agentId;
    this.serverUrl = serverUrl;
    this.wsUrl = serverUrl.replace('http', 'ws');
    this.token = null;
    this.ws = null;
  }

  async register() {
    try {
      console.log(`\nü§ñ Registering agent: ${this.agentId}`);
      
      const response = await axios.post(`${this.serverUrl}/api/agents/register`, {
        agentId: this.agentId,
        config: {
          name: 'Test Unified Agent',
          version: '1.0.0',
          capabilities: ['testing', 'code_generation', 'file_operations'],
          description: 'Test agent for verifying ADE unified infrastructure',
          inputFormats: ['text', 'apml', 'json'],
          outputFormats: ['text', 'json', 'apml'],
          metadata: {
            author: 'ADE Team',
            purpose: 'infrastructure testing'
          }
        }
      });

      this.token = response.data.token;
      console.log('‚úÖ Agent registered successfully');
      console.log(`üîë Token: ${this.token}`);
      console.log(`üìÅ VFS Endpoint: ${response.data.vfsEndpoint}`);
      console.log(`üîå WebSocket: ${response.data.wsEndpoint}`);
      
      return response.data;
    } catch (error) {
      console.error('‚ùå Registration failed:', error.response?.data || error.message);
      throw error;
    }
  }

  async connect() {
    return new Promise((resolve, reject) => {
      console.log(`\nüîå Connecting to WebSocket: ${this.wsUrl}`);
      
      this.ws = new WebSocket(this.wsUrl);
      
      this.ws.on('open', () => {
        console.log('üì° WebSocket connected');
        
        // Authenticate
        this.ws.send(JSON.stringify({
          type: 'agent_connect',
          agentId: this.agentId,
          token: this.token
        }));
      });
      
      this.ws.on('message', (data) => {
        const message = JSON.parse(data);
        
        switch (message.type) {
          case 'connected':
            console.log('‚úÖ Agent authenticated successfully');
            this.startHeartbeat();
            resolve();
            break;
            
          case 'apml_message':
            this.handleAPMLMessage(message.message);
            break;
            
          case 'agent_list':
            console.log(`\nüë• Online agents: ${message.agents.length}`);
            message.agents.forEach(agent => {
              console.log(`   - ${agent.id}: ${agent.capabilities.join(', ')}`);
            });
            break;
            
          case 'vfs_update':
            console.log(`\nüìÅ VFS Update: ${message.path}`);
            break;
            
          case 'error':
            console.error('‚ùå Error:', message.message);
            break;
            
          default:
            console.log('üì® Message:', message);
        }
      });
      
      this.ws.on('error', (error) => {
        console.error('‚ùå WebSocket error:', error);
        reject(error);
      });
      
      this.ws.on('close', () => {
        console.log('üîå WebSocket disconnected');
        this.stopHeartbeat();
      });
    });
  }

  async handleAPMLMessage(message) {
    console.log('\nüì® APML Message received:');
    console.log(`   From: ${message.from}`);
    console.log(`   Type: ${message.type}`);
    console.log(`   Content:`, JSON.stringify(message.content, null, 2));
    
    if (message.type === 'brief') {
      await this.handleBrief(message);
    }
  }

  async handleBrief(message) {
    const { task, context } = message.content;
    console.log(`\nüìã Task received: ${task.description || task}`);
    
    try {
      // Simulate task execution
      console.log('‚öôÔ∏è  Executing task...');
      const result = await this.executeTask(task, context);
      
      // Write output to VFS
      console.log('üíæ Writing to VFS...');
      const vfsResult = await this.writeToVFS('code', result);
      
      // Send report back
      this.sendReport(message.from, task, {
        ...result,
        vfsPath: vfsResult.path
      }, 'completed');
      
    } catch (error) {
      console.error('‚ùå Task execution failed:', error);
      this.sendReport(message.from, task, { error: error.message }, 'failed');
    }
  }

  async executeTask(task, context) {
    // Simulate different task types
    const taskStr = typeof task === 'string' ? task : task.description || '';
    
    if (taskStr.includes('generate') || taskStr.includes('create')) {
      return {
        type: 'code',
        content: `// Generated by ${this.agentId}
// Task: ${taskStr}

export function generatedFunction() {
  console.log("Hello from ADE!");
  return {
    agent: "${this.agentId}",
    timestamp: new Date().toISOString(),
    context: ${JSON.stringify(context, null, 2)}
  };
}`,
        language: 'javascript'
      };
    } else if (taskStr.includes('test')) {
      return {
        type: 'test_results',
        passed: 5,
        failed: 0,
        duration: '1.23s',
        tests: [
          { name: 'agent.register', status: 'passed', duration: '0.12s' },
          { name: 'agent.connect', status: 'passed', duration: '0.23s' },
          { name: 'agent.sendMessage', status: 'passed', duration: '0.15s' },
          { name: 'agent.writeVFS', status: 'passed', duration: '0.45s' },
          { name: 'agent.handleBrief', status: 'passed', duration: '0.28s' }
        ]
      };
    } else {
      return {
        type: 'generic',
        result: `Task completed successfully`,
        task: taskStr,
        agentId: this.agentId,
        timestamp: new Date().toISOString()
      };
    }
  }

  async writeToVFS(type, content) {
    try {
      const response = await axios.post(
        `${this.serverUrl}/api/vfs/output`,
        {
          type: type,
          content: content,
          metadata: {
            timestamp: new Date().toISOString(),
            agent: this.agentId
          }
        },
        {
          headers: {
            'X-Agent-Id': this.agentId,
            'X-Agent-Token': this.token
          }
        }
      );
      
      console.log('‚úÖ Written to VFS:', response.data.path);
      return response.data;
    } catch (error) {
      console.error('‚ùå VFS write failed:', error.response?.data || error.message);
      throw error;
    }
  }

  sendReport(to, taskId, results, status) {
    const message = {
      type: 'apml_message',
      to: to,
      messageType: 'report',
      content: {
        taskId: taskId,
        status: status,
        results: results,
        completedAt: new Date().toISOString()
      }
    };
    
    this.ws.send(JSON.stringify(message));
    console.log(`\nüì§ Report sent to ${to} - Status: ${status}`);
  }

  sendMessage(to, content, messageType = 'info') {
    const message = {
      type: 'apml_message',
      to: to || 'broadcast',
      messageType: messageType,
      content: content
    };
    
    this.ws.send(JSON.stringify(message));
    console.log(`\nüí¨ Message sent to ${to || 'all agents'}`);
  }

  startHeartbeat() {
    this.heartbeatInterval = setInterval(() => {
      if (this.ws.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify({ type: 'heartbeat' }));
      }
    }, 30000);
  }

  stopHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
    }
  }

  disconnect() {
    if (this.ws) {
      this.ws.close();
    }
  }
}

// Test orchestration
async function runTest() {
  console.log('üöÄ ADE Unified Infrastructure Test\n');
  
  // Create multiple test agents
  const agents = [
    new TestUnifiedAgent('test-coder-001'),
    new TestUnifiedAgent('test-designer-002'),
    new TestUnifiedAgent('test-tester-003')
  ];
  
  try {
    // Register all agents
    for (const agent of agents) {
      await agent.register();
      await agent.connect();
    }
    
    console.log('\n‚ú® All agents connected!\n');
    
    // Simulate some interactions
    setTimeout(async () => {
      console.log('\nüé≠ Starting agent interactions...\n');
      
      // Agent 1 sends a broadcast
      agents[0].sendMessage(null, {
        announcement: 'Hello all agents!',
        from: agents[0].agentId
      }, 'broadcast');
      
      // Agent 2 sends task to Agent 1
      await new Promise(resolve => setTimeout(resolve, 1000));
      agents[1].sendMessage(agents[0].agentId, {
        task: 'generate a test file',
        context: { language: 'javascript' }
      }, 'brief');
      
      // Agent 3 sends test request
      await new Promise(resolve => setTimeout(resolve, 2000));
      agents[2].sendMessage('broadcast', {
        request: 'run tests on latest code',
        priority: 'high'
      }, 'test_request');
      
    }, 2000);
    
    console.log('Press Ctrl+C to exit\n');
    
    // Keep process alive
    process.on('SIGINT', () => {
      console.log('\n\nüõë Shutting down...');
      agents.forEach(agent => agent.disconnect());
      process.exit(0);
    });
    
  } catch (error) {
    console.error('‚ùå Test failed:', error);
    process.exit(1);
  }
}

// Run test if called directly
if (require.main === module) {
  runTest();
}

module.exports = TestUnifiedAgent;